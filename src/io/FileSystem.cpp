#include "io/FileSystem.h"

#include <algorithm>
#include <sstream>
#include <cstring>
#include <cassert>
#include <fstream>
#include <filesystem>

#include "pea/config.h"  // This is a configuration file generated by CMake.
#include "util/Log.h"


#include "util/platform.h"
#if TARGET_PLATFORM == PLATFORM_WIN32
#	include <direct.h>
#else
#	include <errno.h>
#	include <sys/stat.h>
#	include <stdlib.h>
#	include <unistd.h>
#endif

using namespace pea;
namespace fs = std::filesystem;

static_assert(column_major == COLUMN_MAJOR, "variables not match, bad config.h file");
static_assert(use_math_xyz == USE_MATH_XYZ, "variables not match, bad config.h file");

static const char* TAG = "File";
const int FileSystem::PATH_MAX_LENGTH = 4096;

#if TARGET_PLATFORM == PLATFORM_WIN32
	const char FileSystem::SEPERATOR = '\\';
#else
	const char FileSystem::SEPERATOR = '/';
#endif

std::string FileSystem::getWorkingDirectory()
{
	char buffer[PATH_MAX_LENGTH];
#if TARGET_PLATFORM == PLATFORM_WIN32
	_getcwd(buffer, PATH_MAX_LENGTH);
#else
	getcwd(buffer, PATH_MAX_LENGTH);
#endif

	return std::string(buffer);
//	fs::current_path().string();  // C++17
}

std::string FileSystem::getRootDirectory()
{
	const char* env = getenv("PEA_HOME");
	if(env)
		return std::string(env);
	
	return std::string(PEA_ROOT_DIRECTORY);
}

std::string FileSystem::getRelativePath(const std::string& path)
{
	assert(path.empty() || path.at(0) != SEPERATOR);
//	static const std::string path = FileSystem::realpath(FileSystem::dirname(__FILE__) + "/../../");
//	return path;
	static std::string root = getRootDirectory() + SEPERATOR;
	return root + path;
}

FileSystem::FileSystem()
{
	
}

FileSystem::~FileSystem()
{
	// TODO Auto-generated destructor stub
}

FileSystem& FileSystem::instace()
{
	static FileSystem filesystem;
	return filesystem;
}

std::vector<std::string> FileSystem::listFiles(const std::string& directory)
{
	std::vector<std::string> paths;
	for(const auto& p: fs::directory_iterator(directory))
		paths.push_back(p.path());
	return paths;
}

char* FileSystem::load(const char* filename)
{
	FILE* file = fopen(filename, "rb");  // open in binary mode, to stay away from CR/LF
	if(!file)
		return nullptr;

	fseek(file, 0, SEEK_END);
	size_t length = ftell(file);
	rewind(file);  // (void)fseek(stream, 0L, SEEK_SET)

	// new in one function and delete in another is a bad habit, it may cause memory leak.
	char* source = static_cast<char*>(malloc(length + 1));
	if(source)
	{
		fread(source, length, 1, file);
		source[length] = '\0';
	}

	fclose(file);
	return source;
}

std::string FileSystem::load(const std::string& filename)
{
/*
	// @see http://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
	// version 1:
	std::ifstream file(filename);
	std::string source((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());

	// version 2:
	std::ifstream file(filename);
	std::string source;

	file.seekg(0, std::ios::end);
	source.reserve(file.tellg());
	file.seekg(0, std::ios::beg);

	source.assign((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());

	// and the final version works like a charm.
	std::stringstream source(filename)
	source << file.rdbuf();
	file.close();
	return source.str();
*/
	std::ifstream file;
	file.open(filename, std::ios::binary);
	if(!file.is_open())
		slog.w(TAG, "invalid filename: %s", filename.c_str());

	std::stringstream source;
	source << file.rdbuf();
	file.close();

	return source.str();
}

/*
	path      dirname  basename
	/usr/lib  /usr     lib
	/usr/     /        usr
	usr       .        usr
	/         /        /
	.         .        .
	..        .        ..
*/
std::string FileSystem::basename(const std::string& path)
{
	size_t end = path.find_last_not_of(SEPERATOR);
	if(end == std::string::npos)
		return path.substr(0, 1);  // [0, 1)

	size_t position = path.find_last_of(SEPERATOR, end);
	if(position == std::string::npos)
		return path.substr(0, end + 1);  // [0, end]

	return path.substr(position + 1, end - position);  // (position , end]
}

std::string FileSystem::dirname(const std::string& path)
{
	size_t end = path.find_last_not_of(SEPERATOR);
	if(end == std::string::npos)
		return path.substr(0, 1);  // [0, 1)

	size_t position = path.find_last_of(SEPERATOR, end);
	if(position == 0)
		return path.substr(0, 1);  // [0, 1)
	else if(position == std::string::npos)
		return std::string(".");  // current directory

	return path.substr(0, position);  // [0, position)
}

std::string FileSystem::realpath(const std::string& path)
{
#ifdef _WIN32
	// Multithreaded applications and shared library code should not use the GetFullPathName 
	// function and should avoid using relative path names.
	// https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx
	TCHAR resolved_path[MAX_PATH];
	DWORD length = GetFullPathName(path.c_str(), MAX_PATH, resolved_path, nullptr);
	if(length != 0)
		return std::string(resolved_path, length);

	slog.e(TAG, "GetFullPathName failed (%d)", GetLastError());
#else
	char* resolved_path = ::realpath(path.c_str(), nullptr);
	if(resolved_path)
		return std::string(resolved_path);

	int code = errno;
	slog.e(TAG, "call realpath(\"%s\") failed, (%d) %s", path.c_str(), code, strerror(code));
#endif
	return std::string();
}

void FileSystem::normalize(std::string& path)
{
	 std::replace(path.begin(), path.end(), '\\', '/');
}

std::string FileSystem::normalize(const std::string& path)
{
#if TARGET_PLATFORM == PLATFORM_WIN32
	std::string path2(path);
	normalize(path2);
	return path2;
#else
	return path;
#endif
}

bool FileSystem::isAbsolute(const std::string& path)
{
	if(path.empty())
		return false;

#if TARGET_PLATFORM == PLATFORM_WIN32
	if(path.size() > 2)
		return path[1] == ':';
#else
	if(path.size() > 1)
		return path[0] == '/';
#endif
	return false;
}

// http://en.cppreference.com/w/cpp/experimental/fs/exists
// http://stackoverflow.com/questions/12774207/fastest-way-to-check-if-a-file-exist-using-standard-c-c11-c#
bool FileSystem::exists(const std::string& path)
{
//	boost::filesystem::exists(path);
#if TARGET_PLATFORM == PLATFORM_WIN32
	std::ifstream file(path);
	return file.good();
#else
	struct stat buffer;
	return stat(path.c_str(), &buffer) == 0;
#endif
}

bool FileSystem::addSearchPath(const std::string& path, bool front /*= true*/)
{
	size_t size = search_path.size();
	for(size_t i = 0; i < size; ++i)
	{
		if(search_path[i] == path)
		{
			// not in the front
			if(front && i != 0)
				std::swap(search_path[0], search_path[i]);

			return false;
		}
	}

	// empty or not found
	search_path.insert(front?search_path.begin():search_path.end(), path);
	return true;
}
